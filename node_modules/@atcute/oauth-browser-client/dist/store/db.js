import { locks } from '../utils/runtime.js';
const parse = (raw) => {
    if (raw != null) {
        const parsed = JSON.parse(raw);
        if (parsed != null) {
            return parsed;
        }
    }
    return {};
};
export const createOAuthDatabase = ({ name }) => {
    const controller = new AbortController();
    const signal = controller.signal;
    const createStore = (subname, expiresAt) => {
        let store;
        const storageKey = `${name}:${subname}`;
        const persist = () => store && localStorage.setItem(storageKey, JSON.stringify(store));
        const read = () => {
            if (signal.aborted) {
                throw new Error(`store closed`);
            }
            return (store ??= parse(localStorage.getItem(storageKey)));
        };
        {
            const listener = (ev) => {
                if (ev.key === storageKey) {
                    store = undefined;
                }
            };
            globalThis.addEventListener('storage', listener, { signal });
        }
        {
            const cleanup = async (lock) => {
                if (!lock || signal.aborted) {
                    return;
                }
                await new Promise((resolve) => setTimeout(resolve, 10_000));
                if (signal.aborted) {
                    return;
                }
                let now = Date.now();
                let changed = false;
                read();
                for (const key in store) {
                    const item = store[key];
                    const expiresAt = item.expiresAt;
                    if (expiresAt !== null && now > expiresAt) {
                        changed = true;
                        delete store[key];
                    }
                }
                if (changed) {
                    persist();
                }
            };
            if (locks) {
                locks.request(`${storageKey}:cleanup`, { ifAvailable: true }, cleanup);
            }
            else {
                cleanup(true);
            }
        }
        return {
            get(key) {
                read();
                const item = store[key];
                if (!item) {
                    return;
                }
                const expiresAt = item.expiresAt;
                if (expiresAt !== null && Date.now() > expiresAt) {
                    delete store[key];
                    persist();
                    return;
                }
                return item.value;
            },
            set(key, value) {
                read();
                const item = {
                    expiresAt: expiresAt(value),
                    value: value,
                };
                store[key] = item;
                persist();
            },
            delete(key) {
                read();
                if (store[key] !== undefined) {
                    delete store[key];
                    persist();
                }
            },
            keys() {
                read();
                return Object.keys(store);
            },
        };
    };
    return {
        dispose: () => {
            controller.abort();
        },
        sessions: createStore('sessions', ({ token }) => {
            if (token.refresh) {
                return null;
            }
            return token.expires_at ?? null;
        }),
        states: createStore('states', (_item) => Date.now() + 10 * 60 * 1_000),
        dpopNonces: createStore('dpopNonces', (_item) => Date.now() + 10 * 60 * 1_000),
    };
};
//# sourceMappingURL=db.js.map