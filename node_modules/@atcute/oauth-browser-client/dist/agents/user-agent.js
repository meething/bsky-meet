import { createDPoPFetch } from '../dpop.js';
import { CLIENT_ID } from '../environment.js';
import { OAuthServerAgent } from './server-agent.js';
import { deleteStoredSession, getSession } from './sessions.js';
export class OAuthUserAgent {
    session;
    #fetch;
    #getSessionPromise;
    constructor(session) {
        this.session = session;
        this.#fetch = createDPoPFetch(CLIENT_ID, session.dpopKey, false);
    }
    get sub() {
        return this.session.info.sub;
    }
    getSession(options) {
        const promise = getSession(this.session.info.sub, options);
        promise
            .then((session) => {
            this.session = session;
        })
            .finally(() => {
            this.#getSessionPromise = undefined;
        });
        return (this.#getSessionPromise = promise);
    }
    async signOut() {
        const sub = this.session.info.sub;
        try {
            const { dpopKey, info, token } = await getSession(sub, { allowStale: true });
            const server = new OAuthServerAgent(info.server, dpopKey);
            await server.revoke(token.refresh ?? token.access);
        }
        finally {
            deleteStoredSession(sub);
        }
    }
    async handle(pathname, init) {
        await this.#getSessionPromise;
        const headers = new Headers(init?.headers);
        let session = this.session;
        let url = new URL(pathname, session.info.aud);
        headers.set('authorization', `${session.token.type} ${session.token.access}`);
        let response = await this.#fetch(url, { ...init, headers });
        if (!isInvalidTokenResponse(response)) {
            return response;
        }
        try {
            if (this.#getSessionPromise) {
                session = await this.#getSessionPromise;
            }
            else {
                session = await this.getSession();
            }
        }
        catch {
            return response;
        }
        // Stream already consumed, can't retry.
        if (init?.body instanceof ReadableStream) {
            return response;
        }
        url = new URL(pathname, session.info.aud);
        headers.set('authorization', `${session.token.type} ${session.token.access}`);
        return await this.#fetch(url, { ...init, headers });
    }
}
const isInvalidTokenResponse = (response) => {
    if (response.status !== 401) {
        return false;
    }
    const auth = response.headers.get('www-authenticate');
    return (auth != null &&
        (auth.startsWith('Bearer ') || auth.startsWith('DPoP ')) &&
        auth.includes('error="invalid_token"'));
};
//# sourceMappingURL=user-agent.js.map